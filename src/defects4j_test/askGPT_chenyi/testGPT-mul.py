import os
import json
import argparse
import sys
import re
import threading
import openai

# Load your OpenAI API key
openai.api_key = "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"

def query_gpt(method_name, class_name, method_info, method_id):
    prompt = f'Import and use `junit4` to write a unit test for method {method_name} in {class_name}, \
    the test case you generate should be wrapped in the corresponding test class \
    which is named "{class_name}_{method_id}Test", to ensure that it runs successfully, \
    here is all the information about the method and the class that this method belongs to: ```{json.dumps(method_info)}``` \
    Make sure maximum coverage of the method body.'

    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": "You are an unit test programmer."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.5,
    )
    return response.choices[0].message['content']

def get_brief_info(_class, method):
    brief_method_info = {}
    # method info
    brief_method_info["identifier"] = method["identifier"]
    brief_method_info["full_signature"] = method["full_signature"]
    brief_method_info["constructor"] = method["constructor"]
    brief_method_info["body"] = method["body"]

    # class that the method belongs to
    brief_class_info = {}
    brief_class_info["identifier"] = _class["identifier"]
    brief_class_info["superclass"] = _class["superclass"]
    brief_class_info["interfaces"] = _class["interfaces"]
    brief_class_info["full_signature"] = _class["full_signature"]
    # brief_class_info["imports"] = method["class"]["imports"] # not work

    brief_class_info["fields"] = []
    for field in _class["fields"]:
        brief_class_info["fields"].append(field["original_string"])

    brief_class_info["methods"] = []
    for m in _class["methods"]:
        if m["full_signature"] == method["full_signature"]:
            continue
        brief_class_info["methods"].append(method["full_signature"])

    brief_method_info["class"] = brief_class_info

    return brief_method_info


# add package and imports
def add_package_imports(method_test_case, package_info, imports):
    for _import in imports:
        method_test_case = _import + "\n" + method_test_case
    method_test_case = package_info + "\n" + method_test_case
    return method_test_case

# Write the test case to a file
def export_method_test_case(output, class_name, id, method_test_case):
    f = os.path.join(output, class_name + "_" + str(id) + "Test.java")
    with open(f, "w") as output_file:
        output_file.write(method_test_case)


# Generate a test case for each method in given class
def generate_tests(class_info, output):
    # Iterate through the methods in the class
    id = 1
    for _class in class_info:
        # method_info = method
        for method in _class['methods']:
            method_info = get_brief_info(_class, method)
            class_name = method_info['class']['identifier']
            method_name = method_info['identifier']
            if output == "./":
                output = os.path.join(output, class_name + "/")
            os.makedirs(output, exist_ok=True)

            # Ask GPT
            print("\nAsking  " + str(class_name) + " : "  + str(method_name) + "...")
            ans = query_gpt(method_name, class_name, method_info, id)
            code = re.search(r"```[Jjava]*([\s\S]*?)```", ans)
            if code:
                # Append the extracted test case to the Java file
                method_test_case = code.group(1)
                export_method_test_case(output, class_name, id, add_package_imports(method_test_case, _class['package'], _class['imports']))
                id += 1
                print("Successfully generate test case for [" + class_name + " : " + method_name + "]")


def job(json_files, output):
    for class_file in json_files:
        # Load the JSON file
        with open(class_file, "r") as json_file:
            class_info = json.load(json_file)
            generate_tests(class_info, output)


def parse_args():
    """
    Parse the args passed from the command line
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--target",
        type = str,
        help = "Target directory path need to test",
    )
    parser.add_argument(
        "--output",
        type = str,
        default = "./",
        help = "Output path of test cases generated by ChatGPT",
    )
    return vars(parser.parse_args())


def main():
    args = parse_args()
    directory = args["target"]
    test_output = args["output"]

    filenames = []
    filenames += [filename for filename in os.listdir(directory) if filename.endswith('.json')]
    file_paths = [os.path.realpath(os.path.join(directory, name)) for name in filenames]

    # Divide the files into 10 chunks for processing
    chunk_size = len(file_paths) // 10 + 1
    filename_chunks = [file_paths[i:i + chunk_size] for i in range(0, len(file_paths), chunk_size)]
    threads = []
    for filename_chunk in filename_chunks:
        thread = threading.Thread(target=job, args=(filename_chunk, test_output))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()
    print("All threads done!")

if __name__ == '__main__':
    main()



